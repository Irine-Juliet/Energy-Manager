================================================================================
                   LOG ACTIVITY FEATURE - BEST PRACTICES RESEARCH
                        Energy Manager Application
================================================================================

PROJECT TECH STACK:
- Django 5.0 (using 4.2)
- Tailwind CSS
- Chart.js
- SQLite

FEATURE REQUIREMENTS:
Users should be able to log an activity with the following attributes:
  • Date
  • Time
  • Name/Activity Name
  • Energy Impact: Increased or Decreased Energy

================================================================================
                            DATABASE LAYER - MODELS
================================================================================

BEST PRACTICES FOR MODEL DESIGN:

1. DATETIME FIELDS IN DJANGO:
   - Use DateField for date-only values
   - Use TimeField for time-only values
   - Use DateTimeField for combined date and time
   - Recommendation: Store combined datetime using DateTimeField for easier querying
   
   Example Model Structure:
   ┌─────────────────────────────────────────────────────────────┐
   │ Activity Model:                                             │
   ├─────────────────────────────────────────────────────────────┤
   │ • id (AutoField - auto-generated)                           │
   │ • name (CharField - activity description)                   │
   │ • datetime (DateTimeField - date + time combined)          │
   │ • energy_impact (IntegerField or CharField with choices)    │
   │ • user (ForeignKey - associate with user)                   │
   │ • created_at (DateTimeField - auto_now_add for tracking)   │
   └─────────────────────────────────────────────────────────────┘

2. ENERGY IMPACT FIELD:
   - Use model choices (TextChoices or IntegerChoices)
   - Django best practice: Define as tuple choices
   - Examples:
     Option A: Simple Boolean-like (INCREASED, DECREASED)
     Option B: Spectrum Range (-2 to +2 as per README energy ratings)
   
   Recommended Implementation (IntegerField with choices):
   ```
   ENERGY_IMPACT_CHOICES = [
       (-2, "Significantly Decreased"),
       (-1, "Slightly Decreased"),
       (1, "Slightly Increased"),
       (2, "Significantly Increased"),
   ]
   ```

3. FIELD VALIDATION:
   - Use Django's built-in validation through field types
   - max_length for activity names (e.g., 255 characters)
   - Allow null=False and blank=False for required fields
   - Consider auto_now_add for created_at timestamp

4. DATABASE CONSIDERATIONS:
   - DateTimeField automatically generates proper SQL (DATETIME in SQLite)
   - Use db_index=True on datetime field for efficient filtering/sorting
   - Consider unique_together or UniqueConstraint for preventing duplicate logs

================================================================================
                            FORM LAYER - FORMS.PY
================================================================================

BEST PRACTICES FOR FORM DESIGN:

1. FORM CLASS APPROACH:
   - Use ModelForm for automatic form generation from Django model
   - Inherits from django.forms.ModelForm
   - Benefits: Automatic field validation, bound to model, less code duplication
   
   ModelForm Structure:
   ```
   class ActivityForm(forms.ModelForm):
       class Meta:
           model = Activity
           fields = ['name', 'datetime', 'energy_impact']
   ```

2. DATE/TIME INPUT WIDGETS:
   Django provides several widget options:
   
   Option A: DateTimeBaseInput (HTML5 datetime-local)
   - Single input field combining date and time
   - Browser provides native picker UI
   - Format: YYYY-MM-DDTHH:mm
   - Best for: Modern browsers, better UX
   
   Option B: SplitDateTimeWidget (separate date and time inputs)
   - Two input fields (date and time)
   - More accessible in some contexts
   - Format: Two separate inputs
   - Best for: Better mobile UX, clearer separation
   
   Option C: Custom widget or library
   - django-crispy-forms, django-widget-tweaks
   - Tailwind CSS integration for styling

3. ENERGY IMPACT FIELD:
   - Use RadioSelect or Select widget
   - RadioSelect better for 2-3 options (clearer)
   - Select widget for longer lists
   - Recommended: RadioSelect for INCREASED/DECREASED choice
   
   Example:
   ```
   energy_impact = forms.ChoiceField(
       widget=forms.RadioSelect(),
       choices=[
           ('increased', 'Increased Energy'),
           ('decreased', 'Decreased Energy'),
       ]
   )
   ```

4. FIELD HELP TEXT & LABELS:
   - Provide clear, user-friendly labels
   - Add help_text for guidance: "Select when this activity occurred"
   - Use required=True/False to control mandatory fields
   
   Example:
   ```
   datetime = forms.DateTimeField(
       label="Activity Date & Time",
       help_text="When did this activity occur?",
       required=True
   )
   ```

5. FORM VALIDATION:
   - Override clean() method for cross-field validation
   - Validate that datetime is not in the future
   - Validate that datetime is not too far in the past
   - Use cleaned_data dictionary
   
   Example:
   ```
   def clean(self):
       cleaned_data = super().clean()
       activity_datetime = cleaned_data.get('datetime')
       if activity_datetime > timezone.now():
           raise ValidationError("Activity time cannot be in the future")
       return cleaned_data
   ```

6. FORM RENDERING IN TEMPLATE:
   - Use {% csrf_token %} for security (POST requests)
   - Render individually with control: {{ form.name }}, {{ form.datetime }}
   - Show errors: {{ form.name.errors }}
   - Use Tailwind classes for styling

================================================================================
                        HTML/FRONTEND LAYER - TEMPLATES
================================================================================

BEST PRACTICES FOR HTML FORM INPUTS:

1. DATE/TIME INPUT TYPES (HTML5):
   - type="datetime-local": Combines date and time in single input
     * Native browser picker (calendar + time selector)
     * Format: YYYY-MM-DDTHH:mm
     * Format displayed: Localized to user's OS settings
     * Best browser support in modern browsers
   
   - type="date": Date only
     * Separate from type="time"
     * Could be combined with type="time" for separate fields
   
   - type="time": Time only (HH:mm format)

2. RECOMMENDED APPROACH FOR ENERGY MANAGER:
   Use type="datetime-local" for single combined input:
   ```html
   <input 
       type="datetime-local" 
       name="datetime" 
       id="id_datetime"
       required
   />
   ```

3. FORM ATTRIBUTES:
   - method="POST" (secure for data mutations)
   - CSRF protection with {% csrf_token %}
   - action points to appropriate view URL
   - enctype="application/x-www-form-urlencoded" (default)

4. LABEL ASSOCIATIONS:
   - Use <label for="id_fieldname"> for accessibility
   - Django automatically generates id attributes
   - Improves mobile usability (larger touch targets)
   - Screen reader friendly

5. ERROR MESSAGING:
   - Display field-specific errors near input
   - Use consistent error styling (Bootstrap/Tailwind classes)
   - Show validation errors before submission attempt
   
   Template pattern:
   ```html
   <div class="field">
       <label for="{{ form.datetime.id_for_label }}">{{ form.datetime.label }}</label>
       {{ form.datetime }}
       {% if form.datetime.errors %}
           <ul class="errors">
               {% for error in form.datetime.errors %}
                   <li>{{ error }}</li>
               {% endfor %}
           </ul>
       {% endif %}
   </div>
   ```

6. BROWSER COMPATIBILITY & FALLBACK:
   - Modern browsers: Use HTML5 inputs (native pickers)
   - Older browsers: May fallback to text input
   - Consider polyfill if needed (html5-input-polyfill)
   - Always validate server-side (never trust client)

7. USER EXPERIENCE CONSIDERATIONS:
   - Don't require unnecessary data
   - Pre-fill with sensible defaults (today's date, current time)
   - Use placeholder text: "YYYY-MM-DD HH:mm"
   - Show format guidance
   - Validate incrementally (on blur, not just submit)

8. TAILWIND CSS STYLING RECOMMENDATIONS:
   Input wrapper: <div class="mb-4">
   Label: <label class="block text-sm font-medium text-gray-700">
   Input: <input class="mt-1 block w-full rounded-md border-gray-300...">
   Error text: <p class="mt-1 text-sm text-red-600">

================================================================================
                        FORM SUBMISSION & VALIDATION FLOW
================================================================================

COMPLETE REQUEST/RESPONSE CYCLE:

1. GET Request (Display Form):
   - User navigates to log_activity page
   - View creates blank/unbound form
   - Template renders form with empty fields
   - JavaScript optional: Set current date/time as default

2. POST Request (Form Submission):
   - User fills form fields
   - User clicks "Save Activity"
   - Browser validates HTML5 constraints (datetime-local)
   - Form data sent to server via POST

3. Server-Side Processing:
   - View receives POST request
   - Create bound form with request.POST data
   - Call form.is_valid()
   - If invalid: Re-render template with error messages
   - If valid: 
     * Access cleaned_data
     * Create Activity instance
     * Save to database
     * Redirect to success page (dashboard or activity history)

4. Error Handling:
   - Client-side: HTML5 validation (browser native)
   - Server-side: Django form validation (essential)
   - Never trust client validation alone
   - Always perform server-side validation

================================================================================
                        JAVASCRIPT ENHANCEMENTS (OPTIONAL)
================================================================================

OPTIONAL FEATURES FOR BETTER UX:

1. SET DEFAULT DATETIME:
   ```javascript
   document.addEventListener('DOMContentLoaded', function() {
       const datetimeInput = document.getElementById('id_datetime');
       const now = new Date();
       const localDateTime = now.toISOString().slice(0, 16);
       datetimeInput.value = localDateTime;
   });
   ```

2. VALIDATION ON CHANGE:
   - Highlight invalid inputs in real-time
   - Disable future dates
   - Show remaining character count for activity name

3. ENERGY IMPACT SELECTION:
   - Use toggle/buttons instead of radio buttons
   - Add icons (⬆️ for increased, ⬇️ for decreased)
   - Visual feedback on selection

================================================================================
                        ACCESSIBILITY & BEST PRACTICES
================================================================================

CRITICAL ACCESSIBILITY FEATURES:

1. SEMANTIC HTML:
   - Use <form> tags properly
   - Use <label> tags (not just placeholder)
   - Use <fieldset> and <legend> for grouping
   - Proper heading hierarchy

2. ARIA ATTRIBUTES:
   - aria-required="true" for required fields
   - aria-invalid="true" on error fields
   - aria-describedby for error/help text

3. KEYBOARD NAVIGATION:
   - Tab order logical (left to right, top to bottom)
   - Focus indicators visible
   - Submit button accessible via keyboard

4. COLOR CONTRAST:
   - Use Tailwind's color utilities
   - Ensure WCAG AA compliance (4.5:1 for text)
   - Don't rely on color alone for errors

5. MOBILE RESPONSIVENESS:
   - Full-width inputs on small screens
   - Touch-friendly button sizes (min 44x44px)
   - datetime-local picker optimized for touch
   - Responsive label/input stacking

================================================================================
                        SECURITY CONSIDERATIONS
================================================================================

CRITICAL SECURITY MEASURES:

1. CSRF PROTECTION:
   - Always include {% csrf_token %} in forms
   - Django middleware validates automatically
   - Essential for POST/PUT/DELETE requests

2. INPUT VALIDATION:
   - Never trust client-side validation alone
   - Django form validation runs server-side
   - Check data types, ranges, lengths

3. SQL INJECTION PREVENTION:
   - Use Django ORM (automatic parameterization)
   - Never use raw SQL with user input
   - DateTimeField handles parsing safely

4. USER AUTHENTICATION:
   - Verify user is authenticated
   - Verify user owns the activity being logged
   - Use login_required decorator on views

5. RATE LIMITING:
   - Consider rate limiting form submissions
   - Prevent spam/abuse of activity logging
   - Implement in middleware or view

================================================================================
                        IMPLEMENTATION CHECKLIST
================================================================================

DATABASE:
☐ Create Activity model with: name, datetime, energy_impact, user, created_at
☐ Use DateTimeField for combined date+time
☐ Add choices for energy_impact (increased/decreased)
☐ Run makemigrations and migrate

FORMS:
☐ Create ActivityForm as ModelForm
☐ Customize datetime widget (datetime-local recommended)
☐ Customize energy_impact widget (RadioSelect recommended)
☐ Add clean() method for datetime validation
☐ Add helpful labels and help_text

VIEWS:
☐ Create log_activity view for GET (display form)
☐ Create log_activity view for POST (process form)
☐ Add login_required decorator
☐ Redirect after successful save
☐ Handle form errors and re-render

TEMPLATES:
☐ Create log_activity.html template
☐ Include {% csrf_token %}
☐ Style with Tailwind CSS
☐ Display field errors clearly
☐ Add submit button
☐ Optional: Add success message

TESTING:
☐ Test form validation with invalid data
☐ Test form validation with future dates
☐ Test successful activity creation
☐ Test with various browsers
☐ Test mobile responsiveness
☐ Test accessibility (keyboard, screen reader)

================================================================================
                        RESOURCES & REFERENCES
================================================================================

Official Documentation:
- Django Models: https://docs.djangoproject.com/en/4.2/topics/db/models/
- Django Forms: https://docs.djangoproject.com/en/4.2/topics/forms/
- HTML5 datetime-local: https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/input/datetime-local

Key Takeaways:
1. Use DateTimeField in model for combined date/time
2. Use ModelForm for automatic validation
3. Use HTML5 datetime-local input for best UX
4. Always validate server-side
5. Implement CSRF protection
6. Follow accessibility guidelines
7. Style with Tailwind CSS
8. Test thoroughly before release

================================================================================
                        ENERGY TRACKER SPECIFIC NOTES
================================================================================

Based on README Requirements:
- README mentions "energy ratings (-2 to +2)"
- Consider expanding model to support numeric scale
- Implement as IntegerField with choices (-2 to +2)
- This allows future analytics (average impact, trends)
- Better for Chart.js visualization in dashboard

Alternative Simple Approach (Binary):
- If only "increased" vs "decreased" needed
- Use BooleanField or CharField with 2 choices
- Simpler for now, can expand later

Recommendation:
Implement numeric scale (-2 to +2) as per README feature list
This aligns with existing "Weekly energy trend visualization" feature
Store as separate fields if needed:
  • impact_type: increased/decreased
  • impact_level: -2, -1, 1, 2

================================================================================
                   MVC/MTV ARCHITECTURE BEST PRACTICES
================================================================================

UNDERSTANDING DJANGO'S MTV PATTERN:

Django follows an MTV (Model-Template-View) architecture, which is a variant of 
the traditional MVC (Model-View-Controller) pattern:

┌─────────────────────────────────────────────────────────────────────────────┐
│                    TRADITIONAL MVC vs DJANGO MTV                            │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  MVC Pattern:                        Django MTV Pattern:                   │
│  ━━━━━━━━━━━━                        ━━━━━━━━━━━━━━━━━━                   │
│                                                                             │
│  Model:                              Model:                                │
│  • Manages data & business logic     • Same as MVC                         │
│  • Database interactions             • ORM for database operations         │
│                                      • Business logic & validation         │
│                                                                             │
│  View:                               Template:                             │
│  • Presentation layer                • Presentation layer                  │
│  • How data is displayed             • HTML rendering                      │
│                                      • Display logic only                  │
│                                                                             │
│  Controller:                         View:                                 │
│  • Request handling                  • Request/response handling           │
│  • Business logic coordination       • What data to show                   │
│  • Routes between M & V              • Delegates to templates              │
│                                                                             │
│  (Django's URLconf acts as the controller/router mechanism)                │
└─────────────────────────────────────────────────────────────────────────────┘

KEY ARCHITECTURAL PRINCIPLES:

1. SEPARATION OF CONCERNS:
   ━━━━━━━━━━━━━━━━━━━━━━
   - Models: Handle data structure, validation, and database operations
   - Views: Handle HTTP request/response logic and data preparation
   - Templates: Handle presentation and display logic only
   - Forms: Handle user input validation and cleaning
   - URLconf: Handle routing (the "controller" in MVC terms)

   Benefits for Energy Manager:
   • Activity model contains all energy tracking logic
   • Views coordinate between forms, models, and analytics
   • Templates only display data, no business logic
   • Easy to test each layer independently

2. LOOSE COUPLING:
   ━━━━━━━━━━━━━━━
   Django's philosophy: "The various layers shouldn't 'know' about each other 
   unless absolutely necessary."

   Implementation Strategy:
   • Template system knows nothing about web requests
   • Database layer knows nothing about data display
   • View system doesn't care which template is used
   • Models can be reused across different views
   • Forms are independent of models (but can integrate via ModelForm)

   Example for Energy Manager:
   ```
   # Activity model doesn't know about HTTP
   class Activity(models.Model):
       name = models.CharField(max_length=255)
       # ... model is self-contained
   
   # View handles HTTP, uses model
   def log_activity(request):
       if request.method == 'POST':
           form = ActivityForm(request.POST)
           if form.is_valid():
               activity = form.save(commit=False)
               activity.user = request.user
               activity.save()
               return redirect('dashboard')
       # ...
   
   # Template only displays, doesn't manipulate
   {{ activity.name }}
   ```

3. DRY PRINCIPLE (Don't Repeat Yourself):
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   "Every distinct concept and/or piece of data should live in one, and only 
   one, place."

   Application to Energy Manager:
   • Activity validation logic → In model's clean() method
   • Form field definitions → ModelForm generates from model
   • Common HTML structure → base.html template with {% extends %}
   • User authentication checks → @login_required decorator
   • Energy calculation logic → Model methods, not views

   Example:
   ```
   # BAD: Repeating validation in form AND view
   if len(activity_name) > 255:  # in view
       return error
   
   # GOOD: Validation once in model
   class Activity(models.Model):
       name = models.CharField(max_length=255)  # automatic validation
   ```

4. EXPLICIT IS BETTER THAN IMPLICIT:
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   From Python's PEP 20, adopted by Django.

   Best Practices:
   • Explicitly call save() on models (don't auto-save)
   • Explicitly define form fields (even if using ModelForm)
   • Explicitly specify template names in views
   • Explicitly handle GET vs POST in views

   Energy Manager Example:
   ```
   # Explicit save with user assignment
   activity = form.save(commit=False)  # Don't save yet
   activity.user = request.user        # Explicit user assignment
   activity.save()                     # Explicit save
   ```

5. INCLUDE ALL RELEVANT DOMAIN LOGIC IN MODELS:
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   Models should follow Martin Fowler's Active Record pattern.

   For Energy Manager Activity Model:
   ```
   class Activity(models.Model):
       name = models.CharField(max_length=255)
       datetime = models.DateTimeField()
       energy_impact = models.IntegerField(choices=ENERGY_CHOICES)
       user = models.ForeignKey(User, on_delete=models.CASCADE)
       
       class Meta:
           ordering = ['-datetime']
           verbose_name_plural = "Activities"
       
       def __str__(self):
           return f"{self.name} - {self.get_energy_impact_display()}"
       
       def is_recent(self):
           """Business logic: Is activity from last 7 days?"""
           from django.utils import timezone
           from datetime import timedelta
           return self.datetime >= timezone.now() - timedelta(days=7)
       
       def energy_impact_numeric(self):
           """Convert impact to numeric for analytics"""
           return self.energy_impact
       
       @classmethod
       def get_weekly_average(cls, user):
           """Analytics logic belongs in model"""
           from django.db.models import Avg
           from datetime import timedelta
           from django.utils import timezone
           
           week_ago = timezone.now() - timedelta(days=7)
           return cls.objects.filter(
               user=user,
               datetime__gte=week_ago
           ).aggregate(Avg('energy_impact'))['energy_impact__avg']
   ```

6. VIEWS SHOULD BE SIMPLE:
   ━━━━━━━━━━━━━━━━━━━━━━
   "Writing a view should be as simple as writing a Python function."

   View Responsibilities:
   ✓ Receive HTTP request
   ✓ Validate & process form data
   ✓ Coordinate between models and forms
   ✓ Prepare context data for templates
   ✓ Return HTTP response
   
   View Should NOT:
   ✗ Contain complex business logic (that's for models)
   ✗ Directly manipulate database (use ORM)
   ✗ Generate HTML (that's for templates)

   Energy Manager Example:
   ```
   @login_required
   def log_activity(request):
       """Simple, focused view function"""
       if request.method == 'POST':
           form = ActivityForm(request.POST)
           if form.is_valid():
               activity = form.save(commit=False)
               activity.user = request.user
               activity.save()
               messages.success(request, 'Activity logged successfully!')
               return redirect('dashboard')
       else:
           form = ActivityForm()
       
       return render(request, 'energy_tracker/log_activity.html', {
           'form': form,
           'page_title': 'Log Activity'
       })
   ```

7. DIFFERENTIATE BETWEEN GET AND POST:
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   Explicitly handle HTTP methods separately.

   Pattern:
   ```
   def view_name(request):
       if request.method == 'POST':
           # Handle form submission
           # Mutate data, save to database
           # Redirect after POST (PRG pattern)
       else:  # GET request
           # Display form
           # Show data
       return render(...)
   ```

8. TEMPLATE LOGIC SEPARATION:
   ━━━━━━━━━━━━━━━━━━━━━━━━━
   "Separate logic from presentation"

   Templates Should:
   ✓ Display data passed from views
   ✓ Use simple template tags ({% if %}, {% for %})
   ✓ Format dates/numbers
   ✓ Extend base templates

   Templates Should NOT:
   ✗ Perform database queries
   ✗ Contain complex Python logic
   ✗ Modify data
   ✗ Make business decisions

   Energy Manager Example:
   ```html
   <!-- GOOD: Simple display logic -->
   <div class="activity-list">
       {% for activity in activities %}
           <div class="activity-card">
               <h3>{{ activity.name }}</h3>
               <p>{{ activity.datetime|date:"F d, Y g:i A" }}</p>
               <span class="{% if activity.energy_impact > 0 %}positive{% else %}negative{% endif %}">
                   {{ activity.get_energy_impact_display }}
               </span>
           </div>
       {% empty %}
           <p>No activities logged yet.</p>
       {% endfor %}
   </div>
   
   <!-- BAD: Complex logic in template -->
   {% for activity in all_activities %}
       {% if activity.datetime > week_ago and activity.user == request.user %}
           <!-- Don't filter in template! Do this in view. -->
       {% endif %}
   {% endfor %}
   ```

9. URL DESIGN BEST PRACTICES:
   ━━━━━━━━━━━━━━━━━━━━━━━━━
   URLs should be clean, predictable, and RESTful.

   Energy Manager URL Structure:
   ```python
   # energy_tracker/urls.py
   urlpatterns = [
       path('', views.homepage, name='homepage'),
       path('dashboard/', views.dashboard, name='dashboard'),
       path('activity/log/', views.log_activity, name='log_activity'),
       path('activity/history/', views.activity_history, name='activity_history'),
       path('activity/<int:pk>/edit/', views.edit_activity, name='edit_activity'),
       path('activity/<int:pk>/delete/', views.delete_activity, name='delete_activity'),
   ]
   ```

   Principles:
   • Use meaningful names (not /page1/, /page2/)
   • Group related URLs (/activity/...)
   • Use named URL patterns (name='log_activity')
   • Never hardcode URLs in templates (use {% url 'name' %})

================================================================================
                   ENERGY MANAGER SPECIFIC ARCHITECTURE
================================================================================

RECOMMENDED STRUCTURE FOR YOUR APPLICATION:

1. MODEL LAYER (energy_tracker/models.py):
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   ```python
   from django.db import models
   from django.contrib.auth.models import User
   from django.utils import timezone
   from datetime import timedelta
   
   class Activity(models.Model):
       ENERGY_IMPACT_CHOICES = [
           (-2, 'Significantly Decreased'),
           (-1, 'Slightly Decreased'),
           (1, 'Slightly Increased'),
           (2, 'Significantly Increased'),
       ]
       
       user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='activities')
       name = models.CharField(max_length=255)
       datetime = models.DateTimeField()
       energy_impact = models.IntegerField(choices=ENERGY_IMPACT_CHOICES)
       notes = models.TextField(blank=True)
       created_at = models.DateTimeField(auto_now_add=True)
       updated_at = models.DateTimeField(auto_now=True)
       
       class Meta:
           ordering = ['-datetime']
           verbose_name_plural = "Activities"
           indexes = [
               models.Index(fields=['-datetime']),
               models.Index(fields=['user', '-datetime']),
           ]
       
       def __str__(self):
           return f"{self.name} ({self.datetime.strftime('%Y-%m-%d')})"
       
       def is_energy_positive(self):
           """Check if activity increased energy"""
           return self.energy_impact > 0
       
       @classmethod
       def get_user_stats(cls, user, days=7):
           """Get statistics for user over specified days"""
           since = timezone.now() - timedelta(days=days)
           activities = cls.objects.filter(user=user, datetime__gte=since)
           
           from django.db.models import Avg, Count
           stats = activities.aggregate(
               avg_impact=Avg('energy_impact'),
               total_count=Count('id'),
               positive_count=Count('id', filter=models.Q(energy_impact__gt=0)),
               negative_count=Count('id', filter=models.Q(energy_impact__lt=0)),
           )
           return stats
       
       @classmethod
       def get_chart_data(cls, user, days=30):
           """Get data formatted for Chart.js"""
           from django.db.models.functions import TruncDate
           from django.db.models import Avg
           
           since = timezone.now() - timedelta(days=days)
           data = cls.objects.filter(
               user=user,
               datetime__gte=since
           ).annotate(
               date=TruncDate('datetime')
           ).values('date').annotate(
               avg_impact=Avg('energy_impact')
           ).order_by('date')
           
           return {
               'labels': [d['date'].strftime('%Y-%m-%d') for d in data],
               'values': [d['avg_impact'] for d in data],
           }
   ```

2. FORM LAYER (energy_tracker/forms.py):
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   ```python
   from django import forms
   from django.utils import timezone
   from .models import Activity
   
   class ActivityForm(forms.ModelForm):
       class Meta:
           model = Activity
           fields = ['name', 'datetime', 'energy_impact', 'notes']
           widgets = {
               'datetime': forms.DateTimeInput(
                   attrs={
                       'type': 'datetime-local',
                       'class': 'form-input rounded-md border-gray-300',
                   }
               ),
               'name': forms.TextInput(
                   attrs={
                       'class': 'form-input rounded-md border-gray-300',
                       'placeholder': 'e.g., Morning run, Coffee break',
                   }
               ),
               'energy_impact': forms.RadioSelect(
                   attrs={'class': 'form-radio'}
               ),
               'notes': forms.Textarea(
                   attrs={
                       'class': 'form-textarea rounded-md border-gray-300',
                       'rows': 3,
                       'placeholder': 'Optional notes about this activity',
                   }
               ),
           }
           labels = {
               'datetime': 'When did this activity occur?',
               'energy_impact': 'How did this affect your energy?',
           }
       
       def clean_datetime(self):
           """Validate datetime is not in the future"""
           dt = self.cleaned_data['datetime']
           if dt > timezone.now():
               raise forms.ValidationError("Cannot log activities in the future.")
           return dt
   ```

3. VIEW LAYER (energy_tracker/views.py):
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   ```python
   from django.shortcuts import render, redirect, get_object_or_404
   from django.contrib.auth.decorators import login_required
   from django.contrib import messages
   from django.http import JsonResponse
   from .models import Activity
   from .forms import ActivityForm
   
   @login_required
   def log_activity(request):
       """Handle activity logging"""
       if request.method == 'POST':
           form = ActivityForm(request.POST)
           if form.is_valid():
               activity = form.save(commit=False)
               activity.user = request.user
               activity.save()
               messages.success(request, 'Activity logged successfully!')
               return redirect('dashboard')
       else:
           form = ActivityForm()
       
       return render(request, 'energy_tracker/log_activity.html', {
           'form': form,
       })
   
   @login_required
   def dashboard(request):
       """Display dashboard with stats and charts"""
       stats = Activity.get_user_stats(request.user, days=7)
       chart_data = Activity.get_chart_data(request.user, days=30)
       recent_activities = Activity.objects.filter(user=request.user)[:10]
       
       context = {
           'stats': stats,
           'chart_data': chart_data,
           'recent_activities': recent_activities,
       }
       return render(request, 'energy_tracker/dashboard.html', context)
   
   @login_required
   def activity_history(request):
       """Display all user activities"""
       activities = Activity.objects.filter(user=request.user)
       
       context = {
           'activities': activities,
       }
       return render(request, 'energy_tracker/activity_history.html', context)
   
   @login_required
   def edit_activity(request, pk):
       """Edit existing activity"""
       activity = get_object_or_404(Activity, pk=pk, user=request.user)
       
       if request.method == 'POST':
           form = ActivityForm(request.POST, instance=activity)
           if form.is_valid():
               form.save()
               messages.success(request, 'Activity updated successfully!')
               return redirect('activity_history')
       else:
           form = ActivityForm(instance=activity)
       
       return render(request, 'energy_tracker/edit_activity.html', {
           'form': form,
           'activity': activity,
       })
   
   @login_required
   def delete_activity(request, pk):
       """Delete activity"""
       activity = get_object_or_404(Activity, pk=pk, user=request.user)
       
       if request.method == 'POST':
           activity.delete()
           messages.success(request, 'Activity deleted successfully!')
           return redirect('activity_history')
       
       return render(request, 'energy_tracker/delete_activity.html', {
           'activity': activity,
       })
   ```

4. TEMPLATE LAYER (templates/energy_tracker/log_activity.html):
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   ```html
   {% extends 'base.html' %}
   
   {% block title %}Log Activity - Energy Manager{% endblock %}
   
   {% block content %}
   <div class="max-w-2xl mx-auto py-8">
       <h1 class="text-3xl font-bold mb-6">Log Activity</h1>
       
       <form method="post" class="space-y-6 bg-white shadow-md rounded-lg p-6">
           {% csrf_token %}
           
           <!-- Activity Name -->
           <div>
               <label for="{{ form.name.id_for_label }}" class="block text-sm font-medium text-gray-700">
                   Activity Name
               </label>
               {{ form.name }}
               {% if form.name.errors %}
                   <p class="mt-1 text-sm text-red-600">{{ form.name.errors.0 }}</p>
               {% endif %}
           </div>
           
           <!-- DateTime -->
           <div>
               <label for="{{ form.datetime.id_for_label }}" class="block text-sm font-medium text-gray-700">
                   {{ form.datetime.label }}
               </label>
               {{ form.datetime }}
               {% if form.datetime.errors %}
                   <p class="mt-1 text-sm text-red-600">{{ form.datetime.errors.0 }}</p>
               {% endif %}
           </div>
           
           <!-- Energy Impact -->
           <div>
               <label class="block text-sm font-medium text-gray-700 mb-2">
                   {{ form.energy_impact.label }}
               </label>
               <div class="space-y-2">
                   {% for radio in form.energy_impact %}
                       <div class="flex items-center">
                           {{ radio.tag }}
                           <label for="{{ radio.id_for_label }}" class="ml-2">
                               {{ radio.choice_label }}
                           </label>
                       </div>
                   {% endfor %}
               </div>
               {% if form.energy_impact.errors %}
                   <p class="mt-1 text-sm text-red-600">{{ form.energy_impact.errors.0 }}</p>
               {% endif %}
           </div>
           
           <!-- Notes (Optional) -->
           <div>
               <label for="{{ form.notes.id_for_label }}" class="block text-sm font-medium text-gray-700">
                   Notes (Optional)
               </label>
               {{ form.notes }}
               {% if form.notes.errors %}
                   <p class="mt-1 text-sm text-red-600">{{ form.notes.errors.0 }}</p>
               {% endif %}
           </div>
           
           <!-- Submit Button -->
           <div class="flex justify-end space-x-3">
               <a href="{% url 'dashboard' %}" class="px-4 py-2 border border-gray-300 rounded-md text-gray-700 hover:bg-gray-50">
                   Cancel
               </a>
               <button type="submit" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700">
                   Log Activity
               </button>
           </div>
       </form>
   </div>
   {% endblock %}
   ```

5. URL CONFIGURATION (energy_tracker/urls.py):
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   Already implemented in your project!

================================================================================
                        KEY TAKEAWAYS FOR ENERGY MANAGER
================================================================================

1. SEPARATION OF CONCERNS:
   • Models = Data structure + business logic + database operations
   • Views = Request handling + coordination + response preparation
   • Templates = Presentation only
   • Forms = Input validation + data cleaning
   • URLs = Routing mechanism

2. DJANGO MTVPattern:
   • Model = Database layer (your Activity model)
   • Template = Presentation layer (your HTML files)
   • View = Logic layer (your view functions)
   • URLconf = Controller/router

3. BEST PRACTICES TO FOLLOW:
   ✓ Keep views simple - delegate to models and forms
   ✓ Put business logic in models (e.g., get_user_stats)
   ✓ Use ModelForm to reduce code duplication
   ✓ Keep templates display-only
   ✓ Use class-based views for complex scenarios (optional)
   ✓ Always use CSRF protection
   ✓ Use @login_required for authenticated views
   ✓ Follow POST-Redirect-GET pattern
   ✓ Use Django's built-in features (don't reinvent)
   ✓ Use database indexes for frequently queried fields

4. SECURITY CONSIDERATIONS:
   ✓ CSRF tokens in all forms
   ✓ Input validation (forms + models)
   ✓ User ownership verification (activity.user == request.user)
   ✓ SQL injection prevention (use ORM, not raw SQL)
   ✓ XSS prevention (Django auto-escapes templates)

5. PERFORMANCE OPTIMIZATIONS:
   ✓ Database indexes on datetime and user fields
   ✓ Use select_related() and prefetch_related() for joins
   ✓ Cache chart data if expensive to calculate
   ✓ Paginate long activity lists
   ✓ Use Django Debug Toolbar in development

================================================================================
                            END OF RESEARCH
================================================================================

````
